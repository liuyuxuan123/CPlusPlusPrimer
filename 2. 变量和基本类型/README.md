## 基本数据类型


### 基本数据类型
类型|长度|取值范围
--|:--|:--:
bool|1|false，true
char|1|-128~127
signed char|1|-128~127
unsigned char|1|0~255
short（signed short）|2|-32768~32767
unsigned short|2|0~65535
int（signed int）|4|-2147483648~2147483647
unsigned int |4 |0~4294967295
long（signed long）|4 |-2147483648~2147483647
unsigned long |4 |0~4294967295
float|4|3.4*10^-38~3.4*10^38
double|8|1.7*10^-308~1.7*10^308
long double|8|1.7*10^-308~1.7*10^308


`ADVICE:`

- 当明确知晓`数值`不可能为`负`时，选用无符号类型。
- 使用`int`执行整数运算。在实际应用中，`short`常常显得太小而`long`一般和`int`有一样的尺寸。如果你的数组超过了`int`的表示范围，选用`long long`。
- 在算术表达式中不要使用`char`或`bool`，只有在存放字符或者布尔值才使用它们。因为类型`char`在一些机器上是有符号的，而在另一台机器上又是无符号的，所以如果使用`char`进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是`signed char`或者`unsigned char`。
- 执行符点运算选用`double`，这是因为`float`通常精度不够而且双精度浮点和单精度浮点的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度运算还快。`long double`提供的精度在一般z情况下是没有必要的，况且它带来的运行时消耗也不容忽视。


### 类型转换

`WARNING：`
尽管我们不会故意给无符号对象赋一个负值，却可能写出这么做的代码。
例如，当个算术表达式中既有无符号数又有`int`值时，那个`int`值就会转化为无符号数。把`int`转化为无符号数的过程和直接把`int`赋值给无符号数一样。
```
    unsigned u = 10;
    int i = -42;
    std::cout << i + i << std::endl; // 输出-84
    std::cout << u + i << std::endl; // 如果int占32位，输出4294967264
```
  当从`无符号数`中减去一个值时，不管这个值是不是无符号数，我们都必须确保`结果`不可以是一个负值。
```
    unsigned u1 = 42, u2 = 10;
    std::cout << u1 - u2 << std::endl; // 输出 32
    std::cout << u2 - u1 << std::endl; // 输出取模后的结果
```
无符号数`不小于0`这一事实同样关系到循环♻️的写法。例如，
```
    for(int i = 10; i >= 0; i --){
        std::cout << i << std::endl;
    }
```
可能你觉得"反正也不打算输出负数，我们可以用无符号数来重写这个循环"。然而，这个不经意的改变切意为着死循环：
```
    // 错误： 变量u永远都不会小于0， 循环条件一种成立
    for(unsigned int u = 10; u >= 0; u --){
        std::cout << u << std::endl;
    }
```
一种解决方案是，用`while语句`代替`for语句`，因为前者让我们在输出变量之前(而非之后)先减去1:
```
    unsigned int u = 11; // 要从11开始
    while(u > 0){
        u --;
        std::cout << u << std::endl;
    }

```
还有一种办法， 可以保存使用`for语句`，就是在输出之前减一。
```
    for(unsigned int u = 11;u > 0; u --){
        std::cout << u - 1 << std::endl;
    }
```

### 字面量常量
`ADVICE:`
    **`字面值常量的形式和值决定了它的数据类型`**
    
#### 整数和浮点数字面值
　　我们可以将整型字面量写作十进制数，八进制数或者十六进制数的形式。以`0`开头的数表示`八进制数`，以`0x`或者`0X`开头的表示`十六进制数`。例如，我们可以用下面任何一种方式表示数值20。
```
    20              /*  十进制  */
    024             /*  八进制  */ 
    0x14            /*  十六进制  */
```
&emsp;整型字面值的具体数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是不带符号的。十进制字面值的`类型`是 `int`， `long`和 `long long`中容纳得下当前值的尺寸最小的那一个。八进制和十六进制字面值的`类型`是能容纳其数值的`int`，`unsigned int`，`long`，`unsigned long`，`long long`和`unsigned long long`中尺寸的最小者。如果一个字面值与之关联的最大数据类型都放不下，将产生错误。类型`short`没有对应的字面值，我们必须以后缀代表对应的字面值类型。

&emsp;尽管整型字面值可以存储在带符号的数据类型中，`但严格来说，十进制字面值不会是负数`。如果我们提供了一个形如`-42`的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负数而已。

&emsp;浮点型字面值表现为一个`小数`或者以`科学技术法表示的指数`，其中指数部分用`E`或者`e`标识。默认的，浮点型字面量是一个`double`，但是我们还是可以用后缀表示其他类型的浮点数。
```
　　  3.14159     3.14159E0     0.     0e0     .001
```
#### 字符和字符串字面值
&emsp;由`单引号`扩起来的一个字符称为`char型字面值`，`双引号`扩起来的`零个或多个字符`则构成`字符串型字面值`。字符串子面子的类型是有常量字符组成的数组。编译器会在每一个字符串的结尾处添加一个空字符`('\0')`。因此，字符串字面值的实际长度比它的内容要多1。如果两个字符串字面值位置邻近且仅由空格，缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式。

```
    // 分行书写的字符串字面值
    std::cout << "a really, really long string literal "
                 "that spans two lines " << std::endl;
```

#### 转义序列
&emsp;有两类字符程序员不可以直接使用： 一类是`不可打印的字符(nonprintable)`，如退格或者其他控制字符，因为它们没有可视的图符； 另一类是`在C++语言中有特殊含义的字符（单引号，双引号，问好，反斜线）`。这些情况下，我们都需要用转义序列，转义序列均以反斜线作为开始，例如，`换行符('\n')`。我们也可以使用范化的转义序列。例如，`换行符('\12')`  。


#### 指定字面值的类型

前缀|含义|类型
--|:--|:--:
`u`|Unicode 16字符|`char16_t`
`U`|Unicode 32字符|`chae32_t`
`L`|宽字符|`wchar_t`
`u8`|UTF-8|`char`

整数类型后缀|最小匹配类型
--|:--:
`u or U`|`unsigned`
`l or L `| `long`
`ll or LL`| `long long`


浮点类型后缀|类型
--|:--:
`f or F`| `float`
`l or L`| `long float`

#### 布尔字面量和指针字面量
**`true和false是布尔型的字面值`**

**`nullptr是指针字面值`**
## 变量
### 初始化
&emsp;当对象在创建时获得了一个特定的值，我们说`这个对象被初始化(initialized)了`。用于初始化变量的值可以是任意复杂的表达式。当一次定义了两个或者多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义语句中，可以使用先定义的变量去初始化后定义的其他变量。
```
    double price = 109.99, discount = price * 0.16;
```
在`C++语言`中，初始化是一个异常复杂的问题，我们也将反复讨论这个问题。很多程序猿对于使用`等号=`来初始化变量的方式倍感困惑，这种方式容易让人认为初始化是赋值的一种。事实上在`C++语言`中，初始化和赋值是两个完全不同的操作。然而在很多编程语言中这两者的区别几乎可以忽略不计，即使在`C++语言`中，有时这种区别也无关紧要，所以人们特别容易把二者混为一谈。需要强调的是，这个概念至关重要。
`WARNING: ` **`初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新的值来替代`**。

#### 初始化方式
```
    int units_sold = 0;
    int units_sold = {0};
    int units_sold{0};
    int units_sold(0);
```
&emsp;`C++语言`定义初始化的好几种不同的形式。作为`C++11`新标准的一部分，使用花括号来初始化变量得到了全面应用。
#### 默认初始化
&emsp;如果定义变量时没有制定初始值，则变量被`默认初始化(Default Initialized)`，此时变量被赋予了`"默认值"`。默认值由变量类型决定，`同时定义变量的位置也会对此有影响`。

&emsp;如果是`内置类型`的变量未被显式初始化，它的值由定义的位置决定。定义与任何函数体之外的变量被初始化为`0`。 一种例外的情况是，定义在函数体内部的内置类型变量将`不被初始化(uninitialized)`。 一个未被初始化的内置类型的值是`未定义的`，如果试图`拷贝`或者`以其他形式访问此类值`将引发错误。 每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。 绝大多数类都支持无需初始化而定义对象，这样的类提供了一个合适的默认值。例如，`string`类规定如果没有制定初始值，则生成一个空字符串。

### 变量申明和变量定义的关系
&emsp;为了允许把程序拆分成多个逻辑部分来编写，`C++语言`支持`分离式编译(Seperate Compilation)`机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。那如果要把程序分为多个文件，则需要有在文件间共享代码的方法。例如， 一个文件的代码可能需要使用另一个文件中定义的变量。一个实际的例子是`std::cout`和`std::cin`，它们定义与标准库，却能被我们写的程序使用。为了支持分离式编译，C++语言将`声明`和`定义`区分开。`声明(declaration)`使得名字为程序所知，一个程序如果想要使用别处定义的名字则必须包含那个名字的声明。而`定义(definition)`则负责创建与名字关联的实体。
```
    extern int i;       // 声明i而非定义i
    int i;              // 声明并定义了i
```
&emsp;任何包含了显示初始化的声明即成为了定义。我们能给由`extern`关键字标记的变量赋一个初始值，但是这样做就抵消了`extern`的作用。`extern`语句如果包含初始值就不再是声明了，而是定义了。

`WARNING: ` 变量能且只能定义一次，但是可以被多次声明。

```
>> iostream 头文件中
namespace std {

    extern istream cin;
    extern ostream cout;
    extern ostream cerr;
    extern ostream clog;
    extern wistream wcin;
    extern wostream wcout;
    extern wostream wcerr;
    extern wostream wclog;

}  // std
```
### 变量作用域
- `全局作用域(Global Scope)`
- `块作用域(Block Scope)`

#### 复合类型
