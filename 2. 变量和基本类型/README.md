## 基本数据类型


### 基本数据类型
类型|长度|取值范围
--|:--|:--:
bool|1|false，true
char|1|-128~127
signed char|1|-128~127
unsigned char|1|0~255
short（signed short）|2|-32768~32767
unsigned short|2|0~65535
int（signed int）|4|-2147483648~2147483647
unsigned int |4 |0~4294967295
long（signed long）|4 |-2147483648~2147483647
unsigned long |4 |0~4294967295
float|4|3.4*10^-38~3.4*10^38
double|8|1.7*10^-308~1.7*10^308
long double|8|1.7*10^-308~1.7*10^308


`ADVICE:`

- 当明确知晓`数值`不可能为`负`时，选用无符号类型。
- 使用`int`执行整数运算。在实际应用中，`short`常常显得太小而`long`一般和`int`有一样的尺寸。如果你的数组超过了`int`的表示范围，选用`long long`。
- 在算术表达式中不要使用`char`或`bool`，只有在存放字符或者布尔值才使用它们。因为类型`char`在一些机器上是有符号的，而在另一台机器上又是无符号的，所以如果使用`char`进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是`signed char`或者`unsigned char`。
- 执行符点运算选用`double`，这是因为`float`通常精度不够而且双精度浮点和单精度浮点的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度运算还快。`long double`提供的精度在一般z情况下是没有必要的，况且它带来的运行时消耗也不容忽视。


### 类型转换

`WARNING：`
尽管我们不会故意给无符号对象赋一个负值，却可能写出这么做的代码。
例如，当个算术表达式中既有无符号数又有`int`值时，那个`int`值就会转化为无符号数。把`int`转化为无符号数的过程和直接把`int`赋值给无符号数一样。
```
    unsigned u = 10;
    int i = -42;
    std::cout << i + i << std::endl; // 输出-84
    std::cout << u + i << std::endl; // 如果int占32位，输出4294967264
```
  当从`无符号数`中减去一个值时，不管这个值是不是无符号数，我们都必须确保`结果`不可以是一个负值。
```
    unsigned u1 = 42, u2 = 10;
    std::cout << u1 - u2 << std::endl; // 输出 32
    std::cout << u2 - u1 << std::endl; // 输出取模后的结果
```
无符号数`不小于0`这一事实同样关系到循环♻️的写法。例如，
```
    for(int i = 10; i >= 0; i --){
        std::cout << i << std::endl;
    }
```
可能你觉得"反正也不打算输出负数，我们可以用无符号数来重写这个循环"。然而，这个不经意的改变切意为着死循环：
```
    // 错误： 变量u永远都不会小于0， 循环条件一种成立
    for(unsigned int u = 10; u >= 0; u --){
        std::cout << u << std::endl;
    }
```
一种解决方案是，用`while语句`代替`for语句`，因为前者让我们在输出变量之前(而非之后)先减去1:
```
    unsigned int u = 11; // 要从11开始
    while(u > 0){
        u --;
        std::cout << u << std::endl;
    }

```
还有一种办法， 可以保存使用`for语句`，就是在输出之前减一。
```
    for(unsigned int u = 11;u > 0; u --){
        std::cout << u - 1 << std::endl;
    }
```

### 字面量常量
`ADVICE:`
    **`字面值常量的形式和值决定了它的数据类型`**
    
#### 整数和浮点数字面值
　　我们可以将整型字面量写作十进制数，八进制数或者十六进制数的形式。以`0`开头的数表示`八进制数`，以`0x`或者`0X`开头的表示`十六进制数`。例如，我们可以用下面任何一种方式表示数值20。
```
    20              /*  十进制  */
    024             /*  八进制  */ 
    0x14            /*  十六进制  */
```
　　整型字面值的具体数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是不带符号的。十进制字面值的`类型`是 `int`， `long`和 `long long`中容纳得下当前值的尺寸最小的那一个。八进制和十六进制字面值的`类型`是能容纳其数值的`int`，`unsigned int`，`long`，`unsigned long`，`long long`和`unsigned long long`中尺寸的最小者。如果一个字面值与之关联的最大数据类型都放不下，将产生错误。类型`short`没有对应的字面值，我们必须以后缀代表对应的字面值类型。
　　
　　尽管整型字面值可以存储在带符号的数据类型中，`但严格来说，十进制字面值不会是负数`。如果我们提供了一个形如`-42`的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负数而已。
　　
　　浮点型字面值表现为一个`小数`或者以`科学技术法表示的指数`，其中指数部分用`E`或者`e`标识。默认的，浮点型字面量是一个`double`，但是我们还是可以用后缀表示其他类型的浮点数。
　　```
　　  3.14159     3.14159E0     0.     0e0     .001
　　```
#### 字符和字符串字面值


